/*

Copyright (C) 2013-2014, Securifera, Inc 

All rights reserved. 

Redistribution and use in source and binary forms, with or without modification, 
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
	this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright notice,
	this list of conditions and the following disclaimer in the documentation 
	and/or other materials provided with the distribution.

    * Neither the name of Securifera, Inc nor the names of its contributors may be 
	used to endorse or promote products derived from this software without specific
	prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS 
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER 
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

================================================================================

Pwnbrew is provided under the 3-clause BSD license above.

The copyright on this package is held by Securifera, Inc

*/


/*
 * FileContent.java
 *
 * Created on June 25, 2013, 8:17 PM
 */

package pwnbrew.xmlBase;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import pwnbrew.misc.Base64Converter;
import pwnbrew.misc.Directories;
import pwnbrew.utilities.FileUtilities;
import pwnbrew.misc.ProgressDriver;
import pwnbrew.misc.ProgressListener;


/**
 *
 *  
 */
@SuppressWarnings("ucd")
public class FileContent extends XmlBase implements ProgressDriver {
    
    private static final int  B64ENCODE_BUFFER_SIZE = 3072;

    private static final String ATTRIBUTE_Hash  = "FileHash";
    static final String ATTRIBUTE_Size = "Size";
    static final String ATTRIBUTE_Base64 = "Base64";
    private static final String ATTRIBUTE_ModifiedDate = "ModifiedDate";
     
    static final String NAME_Class = FileContent.class.getSimpleName();

    //=========================================================================
    /**
     * Constructor
     */
    public FileContent() {
        
        theAttributeMap.put( ATTRIBUTE_Hash, "");
        theAttributeMap.put( ATTRIBUTE_Size, "0");
        theAttributeMap.put( ATTRIBUTE_Base64,  "" );
        
        //Add the attributes
        theAttributeMap.put( ATTRIBUTE_ModifiedDate,  ""  );
    }

    //===============================================================
    /**
    * Sets the hash for the file associated with this file reference
    *
     * @param passedString
    */
    public void setFileHash(String passedString){

        if(passedString != null){
            setAttribute(FileContentRef.ATTRIBUTE_FileHash, passedString);
        }
    }
    
    //===============================================================
    /**
     *  Set the modified
     * 
     * @return 
     */
    public String getModifiedDate(){
        return getAttribute( ATTRIBUTE_ModifiedDate );
    }
    
    //===============================================================
    /**
     *  Sets the modified date.
     * 
     * @param passedDate 
     */
    public void setModifiedDate( String passedDate) {
        setAttribute( ATTRIBUTE_ModifiedDate, passedDate);
    }

    // ==========================================================================
    /**
    * Generates the XML start tag for this object and writes it to the given {@link RandomAccessFile}.
    * <p>
    * In the XML generated by this method, each attribute represents a {@link Field}
    * of this {@code XmlBase}.
    *
    * @param passedFile the {@link RandomAccessFile} to which the XML data is to
    * be written
     * @param isOneLiner
     * @throws java.io.IOException
    *
    * @throws IllegalArgumentException if the argument is null
    */
    @Override
    protected void writeXmlStartTag( RandomAccessFile passedFile, boolean isOneLiner ) throws IOException {

        if( passedFile == null ) { //If the StringBuilder is null...
            throw new IllegalArgumentException( "The RandomAccessFile cannot be null." );
        }

        //Begin the start tag with the class name...
        StringBuilder stringBuilder = new StringBuilder().append( "<" ).append( this.getClass().getSimpleName() );

        //Add the attributes...
        String value = null;
        for( String name : theAttributeMap.keySet() ) { //For each attribute name...

            //Write the base 64 to disk
            if(name.equals(ATTRIBUTE_Base64)){

                stringBuilder.append( " " ); //Add a space
                stringBuilder.append( name ); //Add the attribute name
                stringBuilder.append( "=\"" ); //Add the equals sign and open quote
                passedFile.write(stringBuilder.toString().getBytes("US-ASCII"));

                //Need to get the chars from position to count from the
                //Setup the list of objects needed for the progress function
                List progressList = new ArrayList();
                progressList.add(passedFile);

                stringBuilder = new StringBuilder();
                stringBuilder.append( "\"" ); //Add the close quote

            } else {

                //Set the file size
                if(name.equals(ATTRIBUTE_Size)){
                    File fileContentDir = Directories.getFileLibraryDirectory();
                    String fileHash = getAttribute( ATTRIBUTE_Hash );

                    File aFile = new File(fileContentDir, fileHash);
                    if( FileUtilities.verifyCanRead( aFile ) ) { //If the file can be read...

                        //Calculate the B64 file size
                        long fileLen = aFile.length() - 4/*Size of HEADER*/;
                        long encodingRounds = fileLen / B64ENCODE_BUFFER_SIZE;
                        long totalBasicSize = encodingRounds * Base64Converter.getEncodedLength( B64ENCODE_BUFFER_SIZE);

                        int remainder = (int)(fileLen % B64ENCODE_BUFFER_SIZE);
                        int totalRemSize = Base64Converter.getEncodedLength(remainder);

                        value = Long.toString(totalBasicSize + totalRemSize);
                        theAttributeMap.put(ATTRIBUTE_Size, value);
                    }

                } else {
                    value = theAttributeMap.get( name ); //Get the value mapped to the name
                }

                if (value != null) { //If a value was obtained...

                    stringBuilder.append( " " ); //Add a space
                    stringBuilder.append( name ); //Add the attribute name
                    stringBuilder.append( "=\"" ); //Add the equals sign and open quote
                    stringBuilder.append( XmlUtilities.encode( value ) ); //Add the value
                    stringBuilder.append( "\"" ); //Add the close quote

                    value = null; //Reset for next iteration

                } else { //If no value was obtained...
                //The attribute name/value pair was not added (or was removed) from the
                //  attribute HashMap.
                //Error?
                }

            }

        }

        //Change the start tag to a one-line element...
        if(isOneLiner){
            stringBuilder.append( "/>" ); //Add the one-line terminator "/>"
        } else {
            stringBuilder.append( ">" ); //End the start tag
        }
        passedFile.write(stringBuilder.toString().getBytes("US-ASCII"));

    }/* END writeXmlStartTag( RandomAccessFile ) */


    //======================================================================
    /**
    * The functionality being performed while the progress bar is moving
    * <p>
     * @param progressListener
     * @param passedObjects
     * @return 
    */
    @Override
    public String executeFunction(ProgressListener progressListener, List passedObjects) {

        String retStr = null;
        byte[] byteArray = new byte[ B64ENCODE_BUFFER_SIZE];
//        byte[] theHeader = Utilities.getFileHeader();
//        byte[] headerBytes = new byte[theHeader.length];

        RandomAccessFile passedFile = (RandomAccessFile)passedObjects.get(0);
        File fileContentDir = Directories.getFileLibraryDirectory();
        String fileHash = getAttribute( ATTRIBUTE_Hash );

        //Variables for progress updates
        int sndFileProgress = 0;
        int tempProgressInt = 0;
        double tempProgressDouble = 0;
        long byteCounter = 0;
        long bytesWritten = 0;

        File aFile = new File(fileContentDir, fileHash);
        try {
            if( FileUtilities.verifyCanRead( aFile ) ) { //If the file can be read...

                if(aFile.length() == 0){
                    retStr = "This file contains 0 bytes.";
                } else if(aFile.length() > Integer.MAX_VALUE){
                    retStr = "This file is too large to convert to a library file.";
                }

                long currentFileSize = aFile.length();
                FileInputStream theFileStream = new FileInputStream(aFile);
                BufferedInputStream theBufferedIS = new BufferedInputStream(theFileStream);
                try{

                    //Check the header
                    int bytesRead = 0;

                    //Read in the file bytes
                    while( bytesRead != -1){

                        bytesRead = theBufferedIS.read(byteArray, 0 , byteArray.length);

                        //Write to disk
                        if(bytesRead >= 0){

                            //All encode the bytes read
                            if(bytesRead != byteArray.length){
                                byteArray = Arrays.copyOfRange(byteArray, 0, bytesRead);
                            }

                            //Update counter
                            byteCounter += bytesRead;

                            //Send progress to dialog
                            //Check for divide by zero
                            if(progressListener != null){
                                if(currentFileSize != 0){
                                    tempProgressDouble = (1.0 * byteCounter) / (1.0 * currentFileSize );
                                    tempProgressInt = (int)Math.round(tempProgressDouble * 100.0);
                                }

                                if(tempProgressInt != sndFileProgress){
                                    progressListener.progressChanged(0, tempProgressInt);
                                    sndFileProgress = tempProgressInt;
                                }
                            }

                            String encodedString = Base64Converter.encode(byteArray);
                            byte[] encodedBytes = encodedString.getBytes("US-ASCII");

                            bytesWritten += encodedBytes.length;
                            passedFile.write(encodedBytes);
                        }
                    }

                } finally {
                    theBufferedIS.close();
                }
            }

        } catch (IOException ex){

            //Send back the message
            retStr = ex.getMessage();
        }

        //If the output size does not equal the calculated size
        String calcSize = theAttributeMap.get(ATTRIBUTE_Size);
        if(!calcSize.equals(Long.toString(bytesWritten))){
            retStr = "Unable to export library item, actual file size did not match the one calculated.";
        }

        return retStr;
    }

}/* END CLASS FileContent */
