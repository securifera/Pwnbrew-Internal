/*

Copyright (C) 2013-2014, Securifera, Inc 

All rights reserved. 

Redistribution and use in source and binary forms, with or without modification, 
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
	this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright notice,
	this list of conditions and the following disclaimer in the documentation 
	and/or other materials provided with the distribution.

    * Neither the name of Securifera, Inc nor the names of its contributors may be 
	used to endorse or promote products derived from this software without specific
	prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS 
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER 
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

================================================================================

Pwnbrew is provided under the 3-clause BSD license above.

The copyright on this package is held by Securifera, Inc

*/


/*
 * FileContent.java
 *
 * Created on June 25, 2013, 8:17 PM
 */

package pwnbrew.xml;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;
import pwnbrew.misc.Base64Converter;
import pwnbrew.misc.Directories;
import pwnbrew.utilities.FileUtilities;


/**
 *
 *  
 */
@SuppressWarnings("ucd")
public class FileContent extends XmlObject {
    
    private static final int  B64ENCODE_BUFFER_SIZE = 3072;
    private static final String FILE_HASH  = "FileHash";
    static final String FILE_SIZE = "Size";
    static final String BASE64 = "Base64";
    private static final String MODIFIED_DATE = "ModifiedDate";
     
    static final String NAME_Class = FileContent.class.getSimpleName();

    //=========================================================================
    /**
     * Constructor
     */
    public FileContent() {
        
        thePropertyMap.put( FILE_HASH, "");
        thePropertyMap.put(FILE_SIZE, "0");
        thePropertyMap.put(BASE64,  "" );
        
        //Add the attributes
        thePropertyMap.put( MODIFIED_DATE,  ""  );
    }

    //===============================================================
    /**
    * Sets the hash for the file associated with this file reference
    *
     * @param passedString
    */
    public void setFileHash(String passedString){

        if(passedString != null){
            setProperty(FileContentRef.ATTRIBUTE_FileHash, passedString);
        }
    }
    
    //===============================================================
    /**
     *  Set the modified
     * 
     * @return 
     */
    public String getModifiedDate(){
        return getProperty( MODIFIED_DATE );
    }
    
    //===============================================================
    /**
     *  Sets the modified date.
     * 
     * @param passedDate 
     */
    public void setModifiedDate( String passedDate) {
        setProperty( MODIFIED_DATE, passedDate);
    }

    // ==========================================================================
    /**
    * Generates the XML start tag for this object and writes it to the given {@link RandomAccessFile}.
    * <p>
    * In the XML generated by this method, each attribute represents a {@link Field}
    * of this {@code XmlObject}.
    *
    * @param passedFile the {@link RandomAccessFile} to which the XML data is to
    * be written
     * @param isOneLiner
     * @throws java.io.IOException
    *
    * @throws IllegalArgumentException if the argument is null
    */
    @Override
    protected void writeXmlStartTag( RandomAccessFile passedFile, boolean isOneLiner ) throws IOException {

        if( passedFile == null ) { //If the StringBuilder is null...
            throw new IllegalArgumentException( "The RandomAccessFile cannot be null." );
        }

        //Begin the start tag with the class name...
        StringBuilder stringBuilder = new StringBuilder().append( "<" ).append( this.getClass().getSimpleName() );

        //Add the attributes...
        String value = null;
        for( String name : thePropertyMap.keySet() ) { //For each attribute name...

            //Write the base 64 to disk
            if(name.equals(BASE64)){

                stringBuilder.append( " " ); //Add a space
                stringBuilder.append( name ); //Add the attribute name
                stringBuilder.append( "=\"" ); //Add the equals sign and open quote
                passedFile.write(stringBuilder.toString().getBytes("US-ASCII"));

                //Need to get the chars from position to count from the
                //Setup the list of objects needed for the progress function
                List progressList = new ArrayList();
                progressList.add(passedFile);

                stringBuilder = new StringBuilder();
                stringBuilder.append( "\"" ); //Add the close quote

            } else {

                //Set the file size
                if(name.equals(FILE_SIZE)){
                    File fileContentDir = Directories.getFileLibraryDirectory();
                    String fileHash = getProperty( FILE_HASH );

                    File aFile = new File(fileContentDir, fileHash);
                    if( FileUtilities.verifyCanRead( aFile ) ) { //If the file can be read...

                        //Calculate the B64 file size
                        long fileLen = aFile.length() - 4/*Size of HEADER*/;
                        long encodingRounds = fileLen / B64ENCODE_BUFFER_SIZE;
                        long totalBasicSize = encodingRounds * Base64Converter.getEncodedLength( B64ENCODE_BUFFER_SIZE);

                        int remainder = (int)(fileLen % B64ENCODE_BUFFER_SIZE);
                        int totalRemSize = Base64Converter.getEncodedLength(remainder);

                        value = Long.toString(totalBasicSize + totalRemSize);
                        thePropertyMap.put(FILE_SIZE, value);
                    }

                } else {
                    value = thePropertyMap.get( name ); //Get the value mapped to the name
                }

                if (value != null) { //If a value was obtained...

                    stringBuilder.append( " " ); //Add a space
                    stringBuilder.append( name ); //Add the attribute name
                    stringBuilder.append( "=\"" ); //Add the equals sign and open quote
                    stringBuilder.append( XmlUtilities.encode( value ) ); //Add the value
                    stringBuilder.append( "\"" ); //Add the close quote

                    value = null; //Reset for next iteration

                } else { //If no value was obtained...
                //The attribute name/value pair was not added (or was removed) from the
                //  attribute HashMap.
                //Error?
                }

            }

        }

        //Change the start tag to a one-line element...
        if(isOneLiner){
            stringBuilder.append( "/>" ); //Add the one-line terminator "/>"
        } else {
            stringBuilder.append( ">" ); //End the start tag
        }
        passedFile.write(stringBuilder.toString().getBytes("US-ASCII"));

    }

}